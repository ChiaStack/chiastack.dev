---
title: Try Catch
description: Safe error handling utility
---

The `try-catch` module provides a type-safe error handling function that allows you to gracefully handle errors in asynchronous operations without using traditional try-catch blocks.

## Installation

```bash
npm install @chiastack/utils
```

## Import

```typescript
import { tryCatch } from '@chiastack/utils/try-catch';
```

## API

### `tryCatch`

Execute a Promise or synchronous value and return a result object containing `data` and `error`.

```typescript
tryCatch<T, E = Error>(promise: Promise<T> | T): Promise<TryCatchResult<T, E>>
```

**Parameters:**
- `promise`: Promise or synchronous value to execute

**Returns:**
- `Promise<TryCatchResult<T, E>>`: Result object with the following structure:
  - `{ data: T, error: null }` - On success
  - `{ data: null, error: E }` - On failure

**Example:**

```typescript
import { tryCatch } from '@chiastack/utils/try-catch';

// Handle asynchronous operations
const result = await tryCatch(fetch('/api/data'));

if (result.error) {
  console.error('Error:', result.error);
  // result.data is null here
} else {
  console.log('Data:', result.data);
  // result.error is null here
}

// Handle synchronous values
const syncResult = await tryCatch(JSON.parse('{"valid": true}'));
if (syncResult.error) {
  console.error('Parse failed:', syncResult.error);
} else {
  console.log('Parse successful:', syncResult.data);
}

// Custom error type
interface CustomError {
  code: string;
  message: string;
}

const customResult = await tryCatch<Data, CustomError>(
  fetchData()
);

if (customResult.error) {
  // customResult.error is of type CustomError
  console.error(customResult.error.code);
}
```

## Type Definitions

```typescript
interface TryCatchSuccess<T> {
  data: T;
  error: null;
}

interface TryCatchFailure<E> {
  data: null;
  error: E;
}

type TryCatchResult<T, E = Error> = TryCatchSuccess<T> | TryCatchFailure<E>;
```

## Advantages

- **Type Safe**: TypeScript automatically infers types based on results
- **No try-catch needed**: Avoid nested error handling code
- **Functional Style**: More aligned with functional programming style
- **Easy to Compose**: Can be easily combined with other utility functions

## Use Cases

- API request error handling
- File read/write operations
- Database queries
- Third-party service integration
- Any scenario requiring graceful error handling
